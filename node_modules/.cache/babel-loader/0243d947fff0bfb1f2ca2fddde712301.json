{"ast":null,"code":"var _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar BufferList = require('bl/BufferList');\n\nvar ZERO_OFFSET = '0'.charCodeAt(0);\nvar USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary');\nvar GNU_MAGIC = Buffer.from('ustar\\x20', 'binary');\nvar GNU_VER = Buffer.from('\\x20\\x00', 'binary');\nvar MAGIC_OFFSET = 257;\nvar VERSION_OFFSET = 263;\n\nvar clamp = function clamp(index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue;\n  index = ~~index; // Coerce to integer.\n\n  if (index >= len) return len;\n  if (index >= 0) return index;\n  index += len;\n  if (index >= 0) return index;\n  return 0;\n};\n\nvar toType = function toType(flag) {\n  switch (flag) {\n    case 0:\n      return 'file';\n\n    case 1:\n      return 'link';\n\n    case 2:\n      return 'symlink';\n\n    case 3:\n      return 'character-device';\n\n    case 4:\n      return 'block-device';\n\n    case 5:\n      return 'directory';\n\n    case 6:\n      return 'fifo';\n\n    case 7:\n      return 'contiguous-file';\n\n    case 72:\n      return 'pax-header';\n\n    case 55:\n      return 'pax-global-header';\n\n    case 27:\n      return 'gnu-long-link-path';\n\n    case 28:\n    case 30:\n      return 'gnu-long-path';\n  }\n\n  return null;\n};\n\nvar indexOf = function indexOf(block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block.get(offset) === num) return offset;\n  }\n\n  return end;\n};\n\nvar cksum = function cksum(block) {\n  var sum = 8 * 32;\n\n  for (var i = 0; i < 148; i++) {\n    sum += block.get(i);\n  }\n\n  for (var j = 156; j < 512; j++) {\n    sum += block.get(j);\n  }\n\n  return sum;\n};\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\n\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive;\n  if (buf.get(0) === 0x80) positive = true;else if (buf.get(0) === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest\n\n  var zero = false;\n  var tuple = [];\n\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf.get(i);\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  var sum = 0;\n  var l = tuple.length;\n\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nvar decodeOct = function decodeOct(val, offset, length) {\n  val = val.shallowSlice(offset, offset + length);\n  offset = 0; // If prefixed with 0x80 then parse as a base-256 integer\n\n  if (val.get(offset) & 0x80) {\n    return parse256(val);\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val.get(offset) === 32) {\n      offset++;\n    }\n\n    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);\n\n    while (offset < end && val.get(offset) === 0) {\n      offset++;\n    }\n\n    if (end === offset) return 0;\n    return parseInt(val.shallowSlice(offset, end).toString(), 8);\n  }\n};\n\nvar decodeStr = function decodeStr(val, offset, length, encoding) {\n  return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);\n};\n\nexports.decodeLongPath = function (buf, encoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  return decodeStr(buf, 0, buf.length, encoding);\n};\n\nexports.decodePax = function (buf) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  var result = {};\n\n  while (buf.length) {\n    var i = 0;\n\n    while (i < buf.length && buf.get(i) !== 32) {\n      i++;\n    }\n\n    var len = parseInt(buf.shallowSlice(0, i).toString(), 10);\n    if (!len) return result;\n    var b = buf.shallowSlice(i + 1, len - 1).toString();\n    var keyIndex = b.indexOf('=');\n    if (keyIndex === -1) return result;\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);\n    buf = buf.shallowSlice(len);\n  }\n\n  return result;\n};\n\nexports.decode = function (buf, filenameEncoding) {\n  buf = BufferList.isBufferList(buf) ? buf : new BufferList(buf);\n  var typeflag = buf.get(156) === 0 ? 0 : buf.get(156) - ZERO_OFFSET;\n  var name = decodeStr(buf, 0, 100, filenameEncoding);\n  var mode = decodeOct(buf, 100, 8);\n  var uid = decodeOct(buf, 108, 8);\n  var gid = decodeOct(buf, 116, 8);\n  var size = decodeOct(buf, 124, 12);\n  var mtime = decodeOct(buf, 136, 12);\n  var type = toType(typeflag);\n  var linkname = buf.get(157) === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);\n  var uname = decodeStr(buf, 265, 32);\n  var gname = decodeStr(buf, 297, 32);\n  var devmajor = decodeOct(buf, 329, 8);\n  var devminor = decodeOct(buf, 337, 8);\n  var c = cksum(buf); // checksum is still initial value if header was null.\n\n  if (c === 8 * 32) return null; // valid checksum\n\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');\n\n  if (USTAR_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf.get(345)) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;\n  } else if (GNU_MAGIC.compare(buf.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && GNU_VER.compare(buf.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {// 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    throw new Error('Invalid tar header: unknown format.');\n  } // to support old tar versions that use trailing / to indicate dirs\n\n\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;\n  return {\n    name: name,\n    mode: mode,\n    uid: uid,\n    gid: gid,\n    size: size,\n    mtime: new Date(1000 * mtime),\n    type: type,\n    linkname: linkname,\n    uname: uname,\n    gname: gname,\n    devmajor: devmajor,\n    devminor: devminor\n  };\n};","map":null,"metadata":{},"sourceType":"script"}